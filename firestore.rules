/**
 * @fileoverview Firestore Security Rules for the "Cerdik" application.
 *
 * Core Philosophy:
 * This ruleset employs a strict user-ownership model for user profiles and students data, ensuring that only authenticated users can access their own data.
 * Habit entries are open for public read, while write access is restricted based on the 'recordedBy' field matching the authenticated user.
 * Global application settings are secured for administrative access only.
 *
 * Data Structure:
 * - /users/{userId}: Stores public user profiles, accessible only by the user themselves.
 * - /students/{studentId}: Stores detailed student data, accessible only by the linked user.
 * - /habit_entries/{entryId}: Stores habit entry data. Public read, write restricted to the user who recorded the entry.
 * - /app_settings/{settingId}: Stores global application settings. Write access is denied.
 * - /classes/{classId}: Stores data for each class. Write access is denied.
 *
 * Key Security Decisions:
 * - User profiles can only be read and written by the authenticated user with a matching UID.
 * - Students data can only be read and written by the linked user.
 * - Habit entries are publicly readable, but write access is restricted to the user who recorded the entry.
 * - Listing of documents is generally allowed for owner-only collections.
 * - Global application settings are read-only to prevent unauthorized modifications.
 *
 * Denormalization for Authorization:
 * The `linkedUserUid` field in the `/students/{studentId}` document is used to directly link a student's data to a user's profile, avoiding the need for complex queries.
 */
rules_version = '2';
service cloud.firestore {
  match /databases/{database}/documents {

    /**
     * @description Controls access to user profile documents.
     * @path /users/{userId}
     * @allow (get, create, update, delete, list) if the request is made by the user with matching {userId}.
     * @deny (get, create, update, delete, list) if the request is made by a different user or unauthenticated user.
     * @principle Enforces document ownership for writes and restricts access to a user's own data tree.
     */
    match /users/{userId} {
      function isOwner(userId) {
        return request.auth != null && request.auth.uid == userId;
      }

      function isExistingOwner(userId) {
        return isOwner(userId) && resource != null;
      }

      allow get: if isOwner(userId);
      allow list: if isOwner(userId);
      allow create: if isOwner(userId) && request.resource.data.uid == userId;
      allow update: if isExistingOwner(userId) && request.resource.data.uid == resource.data.uid;
      allow delete: if isExistingOwner(userId);
    }

    /**
     * @description Controls access to student documents.
     * @path /students/{studentId}
     * @allow (get, create, update, delete, list) if the request is made by the linked user.
     * @deny (get, create, update, delete, list) if the request is made by a different user or an unauthenticated user.
     * @principle Enforces document ownership for writes and restricts access to a user's own data tree via `linkedUserUid`.
     */
    match /students/{studentId} {
      function isLinkedUser(linkedUserUid) {
        return request.auth != null && request.auth.uid == linkedUserUid;
      }

      function isExistingLinkedUser(linkedUserUid) {
          return isLinkedUser(linkedUserUid) && resource != null;
      }

      allow get: if isLinkedUser(resource.data.linkedUserUid);
      allow list: if false;
      allow create: if isLinkedUser(request.resource.data.linkedUserUid);
      allow update: if isExistingLinkedUser(resource.data.linkedUserUid) && request.resource.data.linkedUserUid == resource.data.linkedUserUid;
      allow delete: if isExistingLinkedUser(resource.data.linkedUserUid);
    }

    /**
     * @description Controls access to habit entry documents.
     * @path /habit_entries/{entryId}
     * @allow (get, list) to everyone.
     * @allow (create, update, delete) only if the `recordedBy` field matches the authenticated user.
     * @deny (create, update, delete) if the `recordedBy` field does not match the authenticated user or if the user is unauthenticated.
     * @principle Public read access with owner-only writes based on the `recordedBy` field.
     */
    match /habit_entries/{entryId} {
        function isSignedIn() {
            return request.auth != null;
        }

        function isRecorder(recordedBy) {
            return isSignedIn() && request.auth.uid == recordedBy;
        }

        function isExistingRecorder(recordedBy) {
          return isRecorder(recordedBy) && resource != null;
        }

        allow get: if true;
        allow list: if true;
        allow create: if isRecorder(request.resource.data.recordedBy);
        allow update: if isExistingRecorder(resource.data.recordedBy) && request.resource.data.recordedBy == resource.data.recordedBy;
        allow delete: if isExistingRecorder(resource.data.recordedBy);
    }

    /**
     * @description Controls access to app settings documents.
     * @path /app_settings/{settingId}
     * @allow (get, list) to everyone.
     * @deny (create, update, delete) to everyone.
     * @principle Restricts write access to app settings.
     */
    match /app_settings/{settingId} {
      allow get: if true;
      allow list: if true;
      allow create: if false;
      allow update: if false;
      allow delete: if false;
    }

    /**
     * @description Controls access to class data documents.
     * @path /classes/{classId}
     * @allow (get, list) to everyone.
     * @deny (create, update, delete) to everyone.
     * @principle Restricts write access to class data.
     */
    match /classes/{classId} {
      allow get: if true;
      allow list: if true;
      allow create: if false;
      allow update: if false;
      allow delete: if false;
    }
  }
}